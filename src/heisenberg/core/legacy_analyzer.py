"""Main analyzer module - orchestrates the analysis pipeline."""

from __future__ import annotations

from dataclasses import dataclass, field
from pathlib import Path

from heisenberg.integrations.docker import ContainerLogs, DockerLogsCollector
from heisenberg.parsers.playwright import FailedTest, PlaywrightReport, parse_playwright_report

# =============================================================================
# PR Comment Formatting (inlined from utils/comments.py - single use)
# =============================================================================


def format_pr_comment(report: PlaywrightReport) -> str:
    """Format a Playwright report as a GitHub PR comment in Markdown."""
    lines: list[str] = []

    # Header
    lines.append("## Heisenberg Test Analysis")
    lines.append("")

    # Summary stats
    lines.append(_format_summary(report))
    lines.append("")

    # Failed tests details
    if report.has_failures:
        lines.append("### Failed Tests")
        lines.append("")
        for test in report.failed_tests:
            lines.append(_format_failed_test(test))
            lines.append("")
    else:
        lines.append("All tests passed successfully.")
        lines.append("")

    # Footer
    lines.append("---")
    lines.append("*Generated by [Heisenberg](https://github.com/kamilpajak/Heisenberg)*")

    return "\n".join(lines)


def _format_summary(report: PlaywrightReport) -> str:
    """Format the test summary section."""
    parts = []

    if report.total_passed:
        parts.append(f"**{report.total_passed}** passed")
    if report.total_failed:
        parts.append(f"**{report.total_failed}** failed")
    if report.total_skipped:
        parts.append(f"**{report.total_skipped}** skipped")
    if report.total_flaky:
        parts.append(f"**{report.total_flaky}** flaky")

    if not parts:
        return "No tests were run."

    return " | ".join(parts)


def _format_failed_test(test: FailedTest) -> str:
    """Format a single failed test section."""
    lines: list[str] = []

    # Test name with status badge
    status_emoji = _get_status_indicator(test.status)
    lines.append(f"#### {status_emoji} {test.full_name}")
    lines.append("")

    # Metadata table
    lines.append("| Property | Value |")
    lines.append("|----------|-------|")
    lines.append(f"| **File** | `{test.file}` |")
    lines.append(f"| **Project** | {test.project} |")
    lines.append(f"| **Status** | {test.status} |")
    lines.append(f"| **Duration** | {_format_duration(test.duration_ms)} |")

    if test.start_time:
        lines.append(f"| **Started** | {test.start_time.strftime('%Y-%m-%d %H:%M:%S UTC')} |")

    if test.trace_path:
        lines.append("| **Trace** | Available |")

    lines.append("")

    # Error details
    if test.errors:
        lines.append("**Error:**")
        lines.append("```")
        lines.append(_escape_code_block(test.errors[0].message))
        lines.append("```")

        if test.errors[0].stack:
            lines.append("")
            lines.append("<details>")
            lines.append("<summary>Stack trace</summary>")
            lines.append("")
            lines.append("```")
            lines.append(_escape_code_block(test.errors[0].stack))
            lines.append("```")
            lines.append("</details>")

    return "\n".join(lines)


def _get_status_indicator(status: str) -> str:
    """Get a text indicator for test status."""
    indicators = {
        "failed": "[FAIL]",
        "timedOut": "[TIMEOUT]",
        "interrupted": "[INTERRUPTED]",
    }
    return indicators.get(status, "[FAIL]")


def _format_duration(duration_ms: int) -> str:
    """Format duration in human-readable form."""
    if duration_ms < 1000:
        return f"{duration_ms}ms"
    elif duration_ms < 60000:
        seconds = duration_ms / 1000
        return f"{seconds:.1f}s"
    else:
        minutes = duration_ms // 60000
        seconds = (duration_ms % 60000) / 1000
        return f"{minutes}m {seconds:.1f}s"


def _escape_code_block(text: str) -> str:
    """Escape text for use inside markdown code blocks."""
    return text.replace("```", "` ` `")


# =============================================================================
# Analysis Pipeline
# =============================================================================


@dataclass
class AnalysisResult:
    """Result of analyzing test failures."""

    report: PlaywrightReport
    container_logs: dict[str, ContainerLogs] = field(default_factory=dict)

    @property
    def has_failures(self) -> bool:
        """Check if there are any test failures."""
        return self.report.has_failures

    @property
    def summary(self) -> str:
        """Get human-readable summary."""
        return self.report.summary

    def to_markdown(self) -> str:
        """Format result as markdown for PR comment."""
        # Start with the basic report comment
        md = format_pr_comment(self.report)

        # Add container logs if available
        if self.container_logs:
            logs_section = self._format_logs_section()
            # Insert before the footer
            footer_marker = "---\n*Generated by"
            if footer_marker in md:
                parts = md.split(footer_marker)
                md = parts[0] + logs_section + "\n" + footer_marker + parts[1]
            else:
                md += "\n" + logs_section

        return md

    def _format_logs_section(self) -> str:
        """Format container logs as markdown section."""
        lines = [
            "### Backend Logs",
            "",
            "Logs collected from containers around the time of failure:",
            "",
        ]

        for _name, logs in self.container_logs.items():
            lines.append(logs.to_markdown())
            lines.append("")

        return "\n".join(lines)


class Analyzer:
    """Main analyzer that orchestrates the analysis pipeline."""

    def __init__(
        self,
        report_path: Path,
        docker_services: str = "",
        log_window_seconds: int = 30,
    ):
        """
        Initialize analyzer.

        Args:
            report_path: Path to Playwright JSON report.
            docker_services: Comma-separated list of Docker service names.
            log_window_seconds: Time window for log collection.
        """
        self.report_path = report_path
        self.docker_services = docker_services
        self.log_window_seconds = log_window_seconds

    def analyze(self) -> AnalysisResult:
        """
        Run the full analysis pipeline.

        Returns:
            AnalysisResult with parsed report and collected logs.
        """
        # Step 1: Parse Playwright report
        report = parse_playwright_report(self.report_path)

        # Step 2: Collect Docker logs if configured
        container_logs: dict[str, ContainerLogs] = {}

        if self.docker_services and report.has_failures:
            container_logs = self._collect_docker_logs(report)

        return AnalysisResult(
            report=report,
            container_logs=container_logs,
        )

    def _collect_docker_logs(self, report: PlaywrightReport) -> dict[str, ContainerLogs]:
        """Collect and filter Docker logs around failure timestamps."""
        collector = DockerLogsCollector.from_string(self.docker_services)
        all_logs = collector.collect_all()

        if not all_logs:
            return {}

        # Filter logs around each failed test's timestamp
        # For simplicity, we use the earliest failure timestamp
        failure_times = [
            test.start_time for test in report.failed_tests if test.start_time is not None
        ]

        if not failure_times:
            return all_logs

        # Use the earliest failure time as center point
        earliest_failure = min(failure_times)

        filtered_logs: dict[str, ContainerLogs] = {}
        for name, logs in all_logs.items():
            filtered = logs.filter_by_time_window(earliest_failure, self.log_window_seconds)
            if filtered.entries:
                filtered_logs[name] = filtered

        return filtered_logs


def run_analysis(
    report_path: Path,
    docker_services: str = "",
    log_window_seconds: int = 30,
) -> AnalysisResult:
    """
    Convenience function to run analysis.

    Args:
        report_path: Path to Playwright JSON report.
        docker_services: Comma-separated list of Docker service names.
        log_window_seconds: Time window for log collection.

    Returns:
        AnalysisResult with parsed report and collected logs.
    """
    analyzer = Analyzer(
        report_path=report_path,
        docker_services=docker_services,
        log_window_seconds=log_window_seconds,
    )
    return analyzer.analyze()
