"""Formatter for GitHub PR comments."""

from __future__ import annotations

from heisenberg.parsers.playwright import FailedTest, PlaywrightReport


def format_pr_comment(report: PlaywrightReport) -> str:
    """
    Format a Playwright report as a GitHub PR comment in Markdown.

    Args:
        report: Parsed Playwright test report.

    Returns:
        Formatted Markdown string for PR comment.
    """
    lines: list[str] = []

    # Header
    lines.append("## Heisenberg Test Analysis")
    lines.append("")

    # Summary stats
    lines.append(_format_summary(report))
    lines.append("")

    # Failed tests details
    if report.has_failures:
        lines.append("### Failed Tests")
        lines.append("")
        for test in report.failed_tests:
            lines.append(_format_failed_test(test))
            lines.append("")
    else:
        lines.append("All tests passed successfully.")
        lines.append("")

    # Footer
    lines.append("---")
    lines.append("*Generated by [Heisenberg](https://github.com/kamilpajak/Heisenberg)*")

    return "\n".join(lines)


def _format_summary(report: PlaywrightReport) -> str:
    """Format the test summary section."""
    parts = []

    if report.total_passed:
        parts.append(f"**{report.total_passed}** passed")
    if report.total_failed:
        parts.append(f"**{report.total_failed}** failed")
    if report.total_skipped:
        parts.append(f"**{report.total_skipped}** skipped")
    if report.total_flaky:
        parts.append(f"**{report.total_flaky}** flaky")

    if not parts:
        return "No tests were run."

    return " | ".join(parts)


def _format_failed_test(test: FailedTest) -> str:
    """Format a single failed test section."""
    lines: list[str] = []

    # Test name with status badge
    status_emoji = _get_status_indicator(test.status)
    lines.append(f"#### {status_emoji} {test.full_name}")
    lines.append("")

    # Metadata table
    lines.append("| Property | Value |")
    lines.append("|----------|-------|")
    lines.append(f"| **File** | `{test.file}` |")
    lines.append(f"| **Project** | {test.project} |")
    lines.append(f"| **Status** | {test.status} |")
    lines.append(f"| **Duration** | {_format_duration(test.duration_ms)} |")

    if test.start_time:
        lines.append(f"| **Started** | {test.start_time.strftime('%Y-%m-%d %H:%M:%S UTC')} |")

    if test.trace_path:
        lines.append("| **Trace** | Available |")

    lines.append("")

    # Error details
    if test.errors:
        lines.append("**Error:**")
        lines.append("```")
        lines.append(_escape_code_block(test.errors[0].message))
        lines.append("```")

        if test.errors[0].stack:
            lines.append("")
            lines.append("<details>")
            lines.append("<summary>Stack trace</summary>")
            lines.append("")
            lines.append("```")
            lines.append(_escape_code_block(test.errors[0].stack))
            lines.append("```")
            lines.append("</details>")

    return "\n".join(lines)


def _get_status_indicator(status: str) -> str:
    """Get a text indicator for test status."""
    indicators = {
        "failed": "[FAIL]",
        "timedOut": "[TIMEOUT]",
        "interrupted": "[INTERRUPTED]",
    }
    return indicators.get(status, "[FAIL]")


def _format_duration(duration_ms: int) -> str:
    """Format duration in human-readable form."""
    if duration_ms < 1000:
        return f"{duration_ms}ms"
    elif duration_ms < 60000:
        seconds = duration_ms / 1000
        return f"{seconds:.1f}s"
    else:
        minutes = duration_ms // 60000
        seconds = (duration_ms % 60000) / 1000
        return f"{minutes}m {seconds:.1f}s"


def _escape_code_block(text: str) -> str:
    """Escape text for use inside markdown code blocks."""
    # Replace triple backticks to prevent breaking the code block
    return text.replace("```", "` ` `")
