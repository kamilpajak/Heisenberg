"""Main analyzer module - orchestrates the analysis pipeline."""

from __future__ import annotations

from dataclasses import dataclass, field
from pathlib import Path

from heisenberg.comment_formatter import format_pr_comment
from heisenberg.docker_logs import ContainerLogs, DockerLogsCollector
from heisenberg.playwright_parser import PlaywrightReport, parse_playwright_report


@dataclass
class AnalysisResult:
    """Result of analyzing test failures."""

    report: PlaywrightReport
    container_logs: dict[str, ContainerLogs] = field(default_factory=dict)

    @property
    def has_failures(self) -> bool:
        """Check if there are any test failures."""
        return self.report.has_failures

    @property
    def summary(self) -> str:
        """Get human-readable summary."""
        return self.report.summary

    def to_markdown(self) -> str:
        """Format result as markdown for PR comment."""
        # Start with the basic report comment
        md = format_pr_comment(self.report)

        # Add container logs if available
        if self.container_logs:
            logs_section = self._format_logs_section()
            # Insert before the footer
            footer_marker = "---\n*Generated by"
            if footer_marker in md:
                parts = md.split(footer_marker)
                md = parts[0] + logs_section + "\n" + footer_marker + parts[1]
            else:
                md += "\n" + logs_section

        return md

    def _format_logs_section(self) -> str:
        """Format container logs as markdown section."""
        lines = [
            "### Backend Logs",
            "",
            "Logs collected from containers around the time of failure:",
            "",
        ]

        for _name, logs in self.container_logs.items():
            lines.append(logs.to_markdown())
            lines.append("")

        return "\n".join(lines)


class Analyzer:
    """Main analyzer that orchestrates the analysis pipeline."""

    def __init__(
        self,
        report_path: Path,
        docker_services: str = "",
        log_window_seconds: int = 30,
    ):
        """
        Initialize analyzer.

        Args:
            report_path: Path to Playwright JSON report.
            docker_services: Comma-separated list of Docker service names.
            log_window_seconds: Time window for log collection.
        """
        self.report_path = report_path
        self.docker_services = docker_services
        self.log_window_seconds = log_window_seconds

    def analyze(self) -> AnalysisResult:
        """
        Run the full analysis pipeline.

        Returns:
            AnalysisResult with parsed report and collected logs.
        """
        # Step 1: Parse Playwright report
        report = parse_playwright_report(self.report_path)

        # Step 2: Collect Docker logs if configured
        container_logs: dict[str, ContainerLogs] = {}

        if self.docker_services and report.has_failures:
            container_logs = self._collect_docker_logs(report)

        return AnalysisResult(
            report=report,
            container_logs=container_logs,
        )

    def _collect_docker_logs(self, report: PlaywrightReport) -> dict[str, ContainerLogs]:
        """Collect and filter Docker logs around failure timestamps."""
        collector = DockerLogsCollector.from_string(self.docker_services)
        all_logs = collector.collect_all()

        if not all_logs:
            return {}

        # Filter logs around each failed test's timestamp
        # For simplicity, we use the earliest failure timestamp
        failure_times = [
            test.start_time for test in report.failed_tests if test.start_time is not None
        ]

        if not failure_times:
            return all_logs

        # Use the earliest failure time as center point
        earliest_failure = min(failure_times)

        filtered_logs: dict[str, ContainerLogs] = {}
        for name, logs in all_logs.items():
            filtered = logs.filter_by_time_window(earliest_failure, self.log_window_seconds)
            if filtered.entries:
                filtered_logs[name] = filtered

        return filtered_logs


def run_analysis(
    report_path: Path,
    docker_services: str = "",
    log_window_seconds: int = 30,
) -> AnalysisResult:
    """
    Convenience function to run analysis.

    Args:
        report_path: Path to Playwright JSON report.
        docker_services: Comma-separated list of Docker service names.
        log_window_seconds: Time window for log collection.

    Returns:
        AnalysisResult with parsed report and collected logs.
    """
    analyzer = Analyzer(
        report_path=report_path,
        docker_services=docker_services,
        log_window_seconds=log_window_seconds,
    )
    return analyzer.analyze()
